[
["index.html", "Creating APIs in R with Plumber Chapter 1 Introduction 1.1 Web APIs 1.2 Installation", " Creating APIs in R with Plumber Jeff Allen 2017-06-21 Chapter 1 Introduction The R Programming Language (R Core Team 2013) has become one of the most dominant programming languages for data analysis and visualization in recent years. At the same time, web services have become a common language for allowing various systems to interact with one another. The plumber R package (Trestle Technology, LLC 2017) allows users to expose existing R code as a service available to others on the Web. Plumber is best illustrated with an example: # plumber.R #&#39; Echo the parameter that was sent in #&#39; @param msg The message to echo back. #&#39; @get /echo function(msg=&quot;&quot;){ list(msg = paste0(&quot;The message is: &#39;&quot;, msg, &quot;&#39;&quot;)) } #&#39; Plot out data from the iris dataset #&#39; @param spec If provided, filter the data to only this species (e.g. &#39;setosa&#39;) #&#39; @get /plot #&#39; @png function(spec){ myData &lt;- iris title &lt;- &quot;All Species&quot; # Filter if the species was specified if (!missing(spec)){ title &lt;- paste0(&quot;Only the &#39;&quot;, spec, &quot;&#39; Species&quot;) myData &lt;- subset(iris, Species == spec) } plot(myData$Sepal.Length, myData$Petal.Length, main=title, xlab=&quot;Sepal Length&quot;, ylab=&quot;Petal Length&quot;) } Even without knowing R, you can probably get a rough idea for what the above Plumber API will do. The first function above defines the /echo endpoint which simply echoes back the text that it was sent. The second function generates a plot based on Edgar Anderson’s famous Iris Dataset; it includes a filter that allows the caller to subset the dataset to a particular species. Plumber makes use of these comment “annotations” above your functions to define the web service. When you feed the above file into Plumber, you’ll get a runnable web service that other systems can interact with over a network. 1.1 Web APIs The Hypertext Transfer Protocol (HTTP) is the dominant medium by which information is exchanged on the Internet. An Application Programming Interface (API) is a broad term that defines the rules that guide your interaction with some software. In the case of HTTP APIs, you have a defined set of endpoints that accept particular inputs. Plumber translates the annotations you place on your functions into an HTTP API that can be called from other machines on your network. If you execute your Plumber API on a public server, you can even make your API available to the public Internet. HTTP APIs have become the predominant language by which software communicates. By creating an HTTP API, you’ll empower your R code to be leveraged by other services – whether they’re housed inside your organization or hosted on the other side of the world. Here are just a few ideas of the doors that are opened to you when you wrap your R code in a Plumber API: Software written in other languages in your organization can run your R code. Your company’s Java application could now pull in a custom ggplot2 graph that you generate on-demand, or a Python client could query a predictive model defined in R. You can have some third-party receive emails on your behalf and then notify your Plumber service when new messages arrive. You could register a “Slash Command” on Slack, enabling you to execute your R function in response to a command being entered in Slack. You can write JavaScript code that queries your Plumber API from a visitor’s web browser. Even further, you could use Plumber exclusively as the back-end of an interactive web application. 1.2 Installation Plumber is hosted on CRAN, so you can download and install the latest stable version and all of its dependencies by running: install.packages(&quot;plumber&quot;) Alternatively, if you’d like to run the latest unstable development version of plumber, you can install it from its GitHub repository using the devtools package. install.packages(&quot;devtools&quot;) devtools::install_github(&quot;trestletech/plumber&quot;) Once you have plumber installed, see the Quickstart for information on how to get up-and-running with Plumber in minutes. D Citations "],
["quickstart.html", "Chapter 2 Quickstart 2.1 Specifying the Inputs 2.2 Customizing The Output", " Chapter 2 Quickstart Plumber allows you to create APIs by merely decorating your existing R code with special annotations. The example below shows a file named plumber.R (the conventional name for Plumber APIs) which defines an API. # plumber.R #&#39; Echo the parameter that was sent in #&#39; @param msg The message to echo back. #&#39; @get /echo function(msg=&quot;&quot;){ list(msg = paste0(&quot;The message is: &#39;&quot;, msg, &quot;&#39;&quot;)) } #&#39; Plot out data from the iris dataset #&#39; @param spec If provided, filter the data to only this species (e.g. &#39;setosa&#39;) #&#39; @get /plot #&#39; @png function(spec){ myData &lt;- iris title &lt;- &quot;All Species&quot; # Filter if the species was specified if (!missing(spec)){ title &lt;- paste0(&quot;Only the &#39;&quot;, spec, &quot;&#39; Species&quot;) myData &lt;- subset(iris, Species == spec) } plot(myData$Sepal.Length, myData$Petal.Length, main=title, xlab=&quot;Sepal Length&quot;, ylab=&quot;Petal Length&quot;) } This file defines two Plumber “endpoints.” One is hosted at the path /echo and simply echoes the message passed in; the other is hosted at the path /plot and returns an image showing a simple R plot. If you haven’t installed plumber yet, see the installation section. Once you have plumber installed, you can use the plumber::plumb function to translate this R file into a Plumber API: pr &lt;- plumber::plumb(&quot;plumber.R&quot;) The pr object now encapsulates all the logic represented in your plumber.R file. The next step is to bring the API to life using the run method: pr$run() You should see a message about your API running on your computer on port 8000. The API will continue running in your R session until you press the Esc key. If you’re running this code locally on your personal machine, you should be able to open http://localhost:8000/echo or http://localhost:8000/plot in a web browser to test your new API endpoints. If you’re using a tool like RStudio Server to run your R code on a remote machine, you should see the networking section for help with visiting your API. The /echo endpoint should show output resembling the following. { &quot;msg&quot;: [&quot;The message is: &#39;&#39;&quot;] } The /plot endpoint will show you a simple plot of some data from the iris dataset. If you see something like the above: congratulations! You’ve just created your first Plumber API! You’ve already exercised your API from a web browser, but there’s nothing stopping you from leveraging this API from third-party tools or a client developed in R or any other programming language. 2.1 Specifying the Inputs You may have noticed that the functions that define our endpoints accept parameters. These parameters allow us to customize the behavior of our endpoints. One of the ways to do this is using “query strings” which are a way of passing variables into an HTTP API. If you visit http://localhost:8000/plot?spec=setosa, you should see a similar graph to the one you saw before, but now the dataset has been filtered to only include the “setosa” species in the iris dataset. As you might have guessed, the spec=setosa portion of the URL sets the spec parameter to setosa. More details on how Plumber processes inputs are available in the Routing &amp; Input Chapter. 2.2 Customizing The Output In the previous example, you saw one endpoint that rendered into JSON and one that produced an image. Unless instructed otherwise, Plumber will attempt to render whatever your endpoint function returns as JSON. However, you can specify alternative “serializers” which instruct Plumber to render the output as some other format such as HTML (@html), PNG (@png), or JPEG (@jpeg). #&#39; @get /hello #&#39; @html function(){ &quot;&lt;html&gt;&lt;h1&gt;hello world&lt;/h1&gt;&lt;/html&gt;&quot; } This endpoint would produce something like the following, when visited. It also sets the appropriate Content-Type header so that a browser that visits this page would know to render the result as HTML. &lt;html&gt;&lt;h1&gt;hello world&lt;/h1&gt;&lt;/html&gt; You can even provide your own custom serializers and define how to translate the R object produced by your endpoint into the bits that will be produce Plumber’s HTTP response. You can find more details in the Rendering &amp; Output chapter. "],
["routing-and-input.html", "Chapter 3 Routing &amp; Input 3.1 Routing 3.2 Input Handling", " Chapter 3 Routing &amp; Input Plumber’s first job is to execute R code in response to incoming HTTP requests, so it’s important to understand how incoming HTTP requests get translated into the execution of R functions. 3.1 Routing An incoming HTTP request must be “routed” to one or more R functions. Plumber has two distinct families of functions that it handles: endpoints and filters. A typically HTTP request may be routed through some number of filters before ultimately being serviced by a single endpoint. 3.1.1 Endpoints Endpoints are the terminal step in the process of serving a request. An endpoint can simply be viewed as the logic that is ultimately responsible for generating a response to a particular request. A request will be checked against each available endpoint until it finds an endpoint willing to serve it at which point it stops looking; i.e. a request will not ever be processed by more than one endpoint. You create an endpoint by annotating a function like so: #&#39; Echo the parameter that was sent in #&#39; @get /echo function(msg=&quot;Hi!&quot;){ list(msg = paste(&quot;The message is: &quot;, msg)) } This annotation specifies that this function is responsible for generating the response to any GET request to /hello. The value returned from the function will be used as the response to the request (after being run through a serializer to e.g. convert the response into JSON). In this case, a GET response to /hello would return the content [&quot;hello world&quot;] with a JSON Content-Type. The annotations that generate an endpoint include: @get @post @put @delete @head These map to the HTTP methods that an API client might send along with a request. By default when you open a page in a web browser, that sends a GET request to the API. But you can use other API clients (or even JavaScript inside of a web browser) to form HTTP requests using the other methods listed here. There are conventions around when each of these methods should be used which you can read more about here. Note that some of these conventions carry with them security implications, so it’s a good idea to follow the recommended uses for each method until you fully understand why you might deviate from them. Note that a single endpoint can support multiple verbs. The following function would be used to service any incoming GET, POST, or PUT request to /cars. #&#39; @get /cars #&#39; @post /cars #&#39; @put /cars function(){ ... } 3.1.2 Dynamic Routes In addition to having hard-coded routes like /hello, Plumber endpoints can have dynamic routes. Dynamic routes allow endpoints to define a more flexible set of paths against which they should match. A common REST convention is to include the identifier of an object in the API paths associated with it. So to lookup information about user #13, you might make a GET request to the path /users/13. Rather than having to register routes for every user your API might possible encounter, you can use a dynamic route to associate an endpoint with a variety of paths. users &lt;- data.frame( uid=c(12,13), username=c(&quot;kim&quot;, &quot;john&quot;) ) #&#39; Lookup a user #&#39; @get /users/&lt;id&gt; function(id){ subset(users, uid==id) } This API uses the dynamic path /users/&lt;id&gt; to match any request that is of the form /users/ followed by some path element like a number or letters. In this case, it will return information about the user if a user with the associated ID was found, or an empty object if not. You can name these dynamic path elements however you’d like, but note that the name used in the dynamic path must match the name of the parameter for the function (in this case, both id). You can even do more complex dynamic routes like: #&#39; @get /user/&lt;from&gt;/connect/&lt;to&gt; function(from, to){ # Do something with the `from` and `to` variables... } In both the hard-coded and dynamic examples given above, the parameters will be provided to the function as a character string. 3.1.3 Typed Dynamic Routes Unless otherwise instructed, all parameters passed into plumber endpoints from query strings or dynamic paths will be character strings. For example, consider the following API. #&#39; @get /type/&lt;id&gt; function(id){ list( id = id, type = typeof(id) ) } Visiting http://localhost:8000/types/14 will return: { &quot;id&quot;: [&quot;14&quot;], &quot;type&quot;: [&quot;character&quot;] } If you only intend to support a particular data type for a particular parameter in your dynamic route, you can specify the desired type in the route itself. #* @get /user/&lt;id:int&gt; function(id){ next &lt;- id + 1 # ... } #* @post /user/activated/&lt;active:bool&gt; function(active){ if (!active){ # ... } } Specifying the type of a dynamic path element will also narrow the paths that will match the endpoint. For instance, the path /users/123 will match the first endpoint, but /users/8e3k will not, since 8e3k is not an integer. The following details the mapping of the type names that you can use in your dynamic types and how they map to R data types. R Type Plumber Name logical bool, logical numeric double, numeric integer int 3.1.4 Filters Unlike endpoints, a request may go through multiple Plumber filters before being served by an endpoint. //TODO 3.2 Input Handling Plumber routes requests based exclusively on the path and method of the incoming HTTP request, but requests can contain much more information than just this. They might include additional HTTP headers, a query string, or a request body. All of these fields may be viewed as “inputs” to your Plumber API. 3.2.1 The Request Object HTTP requests in Plumber are stored as environments and satisfy the Rook interface. The expected objects for all HTTP requests are the following. Name Example Description cookies list(cook=&quot;abc&quot;) A list of the cookies as described in Cookies httpuv.version &quot;1.3.3&quot; The version of the underlying httpuv package PATH_INFO &quot;/&quot; The path of the incoming HTTP request postBody &quot;a=1&amp;b=2&quot; The contents of the body of the request. Despite the name, it is available for any HTTP method. QUERY_STRING &quot;?a=123&amp;b=abc&quot; The query-string portion of the HTTP request REMOTE_ADDR &quot;1.2.3.4&quot; The IP address of the client making the request REMOTE_PORT &quot;62108&quot; The client port from which the request originated REQUEST_METHOD &quot;GET&quot; The method used for this HTTP request rook.errors N/A See Rook docs rook.input N/A See Rook docs rook.url_scheme &quot;http&quot; The “scheme” (typically http or https). rook.version &quot;1.1-0&quot; The version of the rook specification which this environment satisfies SCRIPT_NAME &quot;&quot; Unused SERVER_NAME &quot;127.0.0.1&quot; The host portion of the incoming request. You may favor HTTP_HOST, if available. SERVER_PORT &quot;8000&quot; The target port for the request HTTP_* &quot;HTTP_USER_AGENT&quot; Entries for all of the HTTP headers sent with this request. 3.2.2 Query Strings A query string may be appended to a URL in order to convey additional information beyond just the request route. Query strings allow for the encoding of character string keys and values. For example, in the URL https://duckduckgo.com/?q=bread&amp;pretty=1, everything following the ? constitutes the query string. In this case, two variables (q and pretty) have been set (to bread and 1, respectively). Plumber will automatically forward information from the query string into the function being executed by aligning the name of the query string with the name of the function parameter. The following example defines a search API that mimics the example from DuckDuckGo above but merely prints out what it receives. #&#39; @get / search &lt;- function(q=&quot;&quot;, pretty=0){ paste0(&quot;The q parameter is &#39;&quot;, q, &quot;&#39;. &quot;, &quot;The pretty parameter is &#39;&quot;, pretty, &quot;&#39;.&quot;) } Visiting http://localhost:8000/?q=bread&amp;pretty=1 will print: [&quot;The q parameter is &#39;bread&#39;. The pretty parameter is &#39;1&#39;.&quot;] This is equivalent to calling search(q=&quot;bread&quot;, pretty=&quot;1&quot;). If a parameter were not specified in the query string, it would just be omitted from the invocation of the endpoint. For example http://localhost:8000/?q=cereal would be equivalent to search(q=&quot;cereal&quot;). The function would fall back to the default value of the pretty parameter (0), since that was defined in the function signature. [&quot;The q parameter is &#39;cereal&#39;. The pretty parameter is &#39;0&#39;.&quot;] Including additional query string arguments that do not map to a parameter of the function has no effect. For instance http://localhost:8000/?test=123 will return the same results as calling search(). [&quot;The q parameter is &#39;&#39;. The pretty parameter is &#39;0&#39;.&quot;] (Note that the raw query string is available as req$QUERY_STRING.) Some web browsers impose limitations on the length of a URL. Internet Explorer, in particular, caps the query string at 2,048 characters. If you need to send large amounts of data from a client to your API, it would likely be a better idea to send it in a request body. //TODO: Redundant keys? 3.2.3 Request Body Another way to provide additional information inside an HTTP request is using the message body. Effectively, once a client specifies all the metadata about a request (the path it’s trying to reach, some HTTP headers, etc.) it can then provide a message body. The maximum size of a request body depends largely on the technologies involved (client, proxies, etc.) but is typically at least 2MB – much larger than a query string. This approach is most commonly seen with PUT and POST requests, though you could encounter it with other HTTP methods. Plumber will attempt to parse the request body in one of two ways: if it appears that the message is JSON, then Plumber will parse the body as a JSON message; otherwise it will decode it as a standard query string. Any fields provided in the message body in either format will be passed through as parameters to the function. Unfortunately, crafting a request with a message body requires a bit more work than making a GET request with a query string from your web browser, but you can use tools like curl on the command line or the httr R package. We’ll use curl for the examples below. #&#39; @post /user function(req, id, name){ list( id = id, name = name, raw = req$postBody ) } Running curl --data &quot;id=123&amp;name=Jennifer&quot; &quot;http://localhost:8000/user&quot; will return: { &quot;id&quot;: [123], &quot;name&quot;: [&quot;Jennifer&quot;], &quot;raw&quot;: [&quot;id=123&amp;name=Jennifer&quot;] } Alternatively, curl --data '{&quot;id&quot;:123, &quot;name&quot;: &quot;Jennifer&quot;}' &quot;http://localhost:8000/user&quot; (formatting the body as JSON) will have the same effect. As demonstrated above, the raw request body is made available as req$postBody. 3.2.4 Cookies If cookies are attached to the incoming request, they’ll be made available via req$cookies. This will contain a list of all the cookies that were included with the request. The names of the list correspond to the names of the cookies and the value for each element will be a character string. See the Setting Cookies section for details on how to set cookies from Plumber. If you’ve set encrypted cookies (as discussed in the Encrypted Cookies section), that session will be decrypted and made available at req$session. 3.2.5 Headers HTTP headers attached to the incoming request are attached to the request object. They are prefixed with HTTP_, the name of the header is capitalized, and hyphens are substituted for underscores. e.g. the Content-Type HTTP header can be found as req$HTTP_CONTENT_TYPE. #&#39; Return the value of a custom header #&#39; @get / function(req){ list( val = req$HTTP_CUSTOMHEADER ) } Running curl --header &quot;customheader: abc123&quot; http://localhost:8000 will return: { &quot;val&quot;: [&quot;abc123&quot;] } You can print out the names of all of the properties attached to the request by running print(ls(req)) inside an endpoint. // TODO: Conflicts between path, query string, body? "],
["rendering-and-output.html", "Chapter 4 Rendering Output 4.1 The Response Object 4.2 Serializers 4.3 Error Handling 4.4 Custom Serializers", " Chapter 4 Rendering Output 4.1 The Response Object // TODO 4.2 Serializers In order to send a response from R to an API client, the object must be “serialized” into some format that the client can understand. JavaScript Object Notation (JSON) is one standard which is commonly used by web APIs. JSON serialization translates R objects like list(a=123, b=&quot;hi!&quot;) to JSON text resembling {a: 123, b: &quot;hi!&quot;}. JSON is not appropriate for every situation, however. If you want your API to render an HTML page that might be viewed in a browser, for instance, you will need a different serializer. Likewise, if you want to return an image rendered in R, you likely want to use a standard image format like PNG or JPEG rather than JSON. By default, Plumber serializes objects into JSON via the jsonlite R package. However, there are a variety of other serializers that are built in to the package. Annotation Content Type Description/References @json application/json jsonlite::toJSON() @html text/html; charset=utf-8 Passes response through without any additional serialization @jpeg image/jpeg jpeg() @png image/png png() @htmlwidget text/html; charset=utf-8 htmlwidgets::saveWidget() @unboxedJSON application/json jsonlite::toJSON(unboxed=TRUE) 4.2.1 Bypassing Serialization In some instances it may be desirable to return a value directly from R without serialization. You can bypass serialization by returning the response object from an endpoint. For example, consider the following API. #&#39; Endpoint that bypasses serialization #&#39; @get / function(res){ res$body &lt;- &quot;Literal text here!&quot; res } The response that is returned from this endpoint would contain the body Literal text here! with no Content-Type header and without any additional serialization. Similarly, you can leverage the @serializer contentType annotation which does no serialization of the response but specifies the contentType header. You can use this annotation when you want more control over the response that you send. #* @serializer contentType list(type=&quot;application/pdf&quot;) #* @get /pdf function(){ tmp &lt;- tempfile() pdf(tmp) plot(1:10, type=&quot;b&quot;) text(4, 8, &quot;PDF from plumber!&quot;) text(6, 2, paste(&quot;The time is&quot;, Sys.time())) dev.off() readBin(tmp, &quot;raw&quot;, n=file.info(tmp)$size) } Running this API and visiting http://localhost:8000/pdf will download the PDF generated from R (or display the PDF natively, if your client supports it). 4.2.2 Boxed vs Unboxed JSON You may have noticed that API responses generated from Plumber render singular values (or “scalars”) as arrays. For instance: jsonlite::toJSON(list(a=5)) ## {&quot;a&quot;:[5]} The value of the a element, though it’s singular, is still rendered as an array. This may surprise you initially, but this is done to keep the output consistent. While JSON differentiates scalar from vector objects, R does not. This creates ambiguity when serializing an R object to JSON since it is unclear whether a particular element should be rendered as an atomic value or a JSON array. Consider the following API which returns all the letters lexicographically “higher” than the given letter. #&#39; Get letters after a given letter #&#39; @get /boxed function(letter=&quot;A&quot;){ LETTERS[LETTERS &gt; letter] } #&#39; Get letters after a given letter #&#39; @serializer unboxedJSON #&#39; @get /unboxed function(letter=&quot;A&quot;){ LETTERS[LETTERS &gt; letter] } This is an example of an API that, in some instance, produces a scalar, and in other instances produces a vector. Visiting http://localhost:8000/boxed?letter=U or http://localhost:8000/unboxed?letter=U will return identical responses: [&quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;] However, http://localhost:8000/boxed?letter=Y will produce: [&quot;Z&quot;] while http://localhost:8000/unboxed?letter=Y will produce: &quot;Z&quot; The /boxed endpoint, as the name implies, produces “boxed” JSON output in which length-1 vectors are still rendered as an array. Conversely, the /unboxed endpoint sets auto_unbox=TRUE in its call to jsonlite::toJSON, causing length-1 R vectors to be rendered as JSON scalars. While R doesn’t distinguish between scalars and vectors, API clients may respond very differently when encountering a JSON array versus an atomic value. You may find that your API clients will not respond gracefully when an object that they expected to be a vector becomes a scalar in one call. For this reason, Plumber inherits the jsonlite::toJSON default of setting auto_unbox=FALSE which will result in all length-1 vectors still being rendered as JSON arrays. You can configure an endpoint to use the unboxedJSON serializer (as shown above) if you want to alter this behavior for a particular endpoint. There are a couple of functions to be aware of around this feature set. If using boxed JSON serialization, jsonlite::unbox() can be used to force a length-1 object in R to be presented in JSON as a scalar. If using unboxed JSON serialization, I() will cause a length-1 R object to present as a JSON array. 4.3 Error Handling Plumber wraps each endpoint invocation so that it can gracefully capture errors. #&#39; Example of throwing an error #&#39; @get /simple function(){ stop(&quot;I&#39;m an error!&quot;) } #&#39; Generate a friendly error #&#39; @get /friendly function(res){ msg &lt;- &quot;Your request did not include a required parameter.&quot; res$status &lt;- 400 # Bad request list(error=jsonlite::unbox(msg)) } If you run this API and visit http://localhost:8000/simple, you’ll notice two things: An HTTP response with a status code of 500 (“internal server error”) is sent to the client. You should see an error message resembling: {&quot;error&quot;:[&quot;500 - Internal server error&quot;],&quot;message&quot;:[&quot;Error in (function () : I'm an error!\\n&quot;]} A similar error is printed in the terminal where you’re running your Plumber API. This means that it is possible for you to intentionally stop() in an endpoint or a filter as a way to communicate a problem to your user. However, it may be preferable to render errors from your API in a consistent format with more helpful error messages. { &quot;error&quot;: &quot;Your request did not include a required parameter.&quot; } 4.4 Custom Serializers // TODO "],
["runtime.html", "Chapter 5 Runtime 5.1 Execution Model 5.2 Managing State", " Chapter 5 Runtime Rename this chapter. I don’t know what to call it. 5.1 Execution Model Execution model - what gets run at plumb() and run() time. Not sure if this really belongs here, but not sure where else to put it if not a new chapter. 5.2 Managing State - In-memory Environments and &lt;&lt;-. BAD, STATELESS - Cookies - Concurrent programming (if multiple proc&#39;s) "],
["tips-tricks.html", "Chapter 6 Tips &amp; Tricks 6.1 Cookies", " Chapter 6 Tips &amp; Tricks //TODO - Debugging - Testing - Managing State - In-memory Environments and &lt;&lt;-. BAD, STATELESS - Cookies - Concurrent programming (if multiple proc’s) - Organizing Large Applications - Swagger 6.1 Cookies //TODO - see https://plumber.trestletech.com/docs/sessions/ for a good start – the last section on that page might be good here. 6.1.1 Setting Unencrypted Cookies HTTP APIs don’t implicitly contain a notion of a “session.” Without some additional information, Plumber has no way of ascertaining whether or not two HTTP requests that come in are associated with the same user. Cookies offer a way to commission the client to store some state on your behalf so that selected data can outlive a single HTTP request. Plumber can both set and receive cookies. For details on setting cookies, see the Setting Cookies section. The API below will send you a random letter, but it remembers your preferences on whether you like capitalized or lower-case letters. #&#39; @put /preferences function(res, capital){ if (missing(capital)){ stop(&quot;You must specify a value for the &#39;capital&#39; preference.&quot;) } res$setCookie(&quot;capitalize&quot;, capital) } #&#39; @get /letter function(req) { print(ls(req)) capitalize &lt;- req$cookies$capitalize # Default to lower-case unless user preference is capitalized alphabet &lt;- letters # The capitalize cookie will initially be empty (NULL) if (!is.null(capitalize) &amp;&amp; capitalize == &quot;1&quot;){ alphabet &lt;- LETTERS } list( letter = sample(alphabet, 1) ) } Since we need to craft a PUT request to test this API, we’ll use curl on the command line to test it. We can start by visiting the /letter endpoint and we’ll see that the API defaults to a lower-case alphabet. curl http://localhost:8000/letter [1] &quot;cookies&quot; { &quot;letter&quot;: [&quot;c&quot;] } If we send a PUT request and specify the capital parameter, a cookie will be set on the client which will allow the server to accommodate our preference in future requests. In curl, you need to specify a file in which you want to save these cookies using the -c option. This is a good reminder that clients handle cookies differently – some won’t support them at all – so be sure that the clients you intend to support with your API play nicely with cookies if you want to use them. To send a PUT request, setting the parameter capital to 1, we could invoke: curl -c cookies.txt -X PUT --data 'capital=1' &quot;http://localhost:8000/preferences&quot;. If you print out the cookies.txt file, you should now see that it contains a single cookie called capitalize with a value of 1. We can make another GET request to /letter to see if it accommodates our preferences. But we’ll need to tell curl to use the cookies file we just created when sending this request using the -b switch: curl -b cookies.txt http://localhost:8000/letter. You should now see that the API is returning a random capitalized letter. This is a simple example showing how to persist user preferences across HTTP requests using cookies. But be aware that the client has the ability to modify or fabricate the cookies that they send to your API. So storing preferences that the user themselves provided in a cookie is not a concern. Storing something with security implications like the level of permissions this client has on your API, however, would be; a malicious user would just need to modify the role saved in their cookie in order to trick your API into giving them more permissions than it should. There are two common work-arounds to this concern. You can simply store a long (cryptographically) random identifier in the user’s cookie, and have some mapping on the server that allows you to lookup the session associated with that random ID. Alternatively, you could use signed/encrypted cookies, as detailed below. 6.1.2 Setting Encrypted Cookies //TODO: See https://plumber.trestletech.com/docs/sessions/ – it’s got a pretty good start "],
["hosting-and-security.html", "Chapter 7 Hosting &amp; Security", " Chapter 7 Hosting &amp; Security Reasons why you shouldn’t host on your desktop or RStudio IDE DO RSC Docker pm2 Security CORS XSRF Injection DOS – check numerical inputs. Networking &amp; Firewalls {#networking} How to access an API running on a remote machine (referenced this in the quickstart) "],
["all-annotations.html", "A All Annotations", " A All Annotations "],
["preprocessors.html", "B Preprocessors", " B Preprocessors "],
["programmatic-usage.html", "C Programmatic Usage", " C Programmatic Usage "],
["citations.html", "D Citations", " D Citations "]
]
